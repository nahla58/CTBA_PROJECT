# main.py - API CTBA DYNAMIQUE AVEC AUTOMATISATION
from fastapi import FastAPI, HTTPException, WebSocket, WebSocketDisconnect
from fastapi.middleware.cors import CORSMiddleware
import sqlite3
import json
from datetime import datetime, timezone, timedelta
from typing import Optional, List
import threading
import schedule
import time
import requests
import asyncio

# ========== 1. CR√âER L'APPLICATION ==========
app = FastAPI(
    title="CTBA API - Version Dynamique",
    description="API pour la gestion des CVE avec automatisation NVD",
    version="2.0.0"
)

# ========== 2. AUTORISER REACT ==========
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],  # React
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# ========== 3. WEBSOCKET POUR MISE √Ä JOUR EN TEMPS R√âEL ==========
class ConnectionManager:
    def __init__(self):
        self.active_connections: List[WebSocket] = []

    async def connect(self, websocket: WebSocket):
        await websocket.accept()
        self.active_connections.append(websocket)

    def disconnect(self, websocket: WebSocket):
        self.active_connections.remove(websocket)

    async def broadcast(self, message: str):
        for connection in self.active_connections:
            try:
                await connection.send_text(message)
            except:
                pass

manager = ConnectionManager()

@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    await manager.connect(websocket)
    try:
        while True:
            # Attendre des messages (maintenir la connexion)
            await websocket.receive_text()
    except WebSocketDisconnect:
        manager.disconnect(websocket)
        print("üîå Client WebSocket d√©connect√©")

# ========== 4. BASE DE DONN√âES ==========
def init_database():
    """Cr√©e ou met √† jour la base de donn√©es SQLite"""
    conn = sqlite3.connect("ctba.db")
    cursor = conn.cursor()
    
    # Table CVE
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS cves (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            cve_id TEXT UNIQUE NOT NULL,
            description TEXT,
            severity TEXT,
            cvss_score REAL,
            published_date TEXT,
            status TEXT DEFAULT 'PENDING',
            imported_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
    ''')
    
    # Table d√©cisions
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS decisions (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            cve_id TEXT,
            decision TEXT,
            analyst TEXT,
            comments TEXT,
            decision_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
    ''')
    
    # Table d'audit pour les imports
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS imports_audit (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            import_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            cves_found INTEGER,
            cves_added INTEGER,
            duration_seconds REAL
        )
    ''')
    
    # Ajouter une CVE de test si totalement vide
    cursor.execute("SELECT COUNT(*) FROM cves")
    if cursor.fetchone()[0] == 0:
        cursor.execute('''
            INSERT INTO cves (cve_id, description, severity, cvss_score, published_date)
            VALUES (?, ?, ?, ?, ?)
        ''', (
            "CVE-2024-99999",
            "Vulnerability test pour d√©monstration",
            "HIGH",
            7.5,
            datetime.now(timezone.utc).isoformat()
        ))
        print("‚úÖ CVE de test ajout√©e")
    
    conn.commit()
    conn.close()
    print("‚úÖ Base de donn√©es initialis√©e")

# ========== 5. IMPORTATION DYNAMIQUE NVD ==========
def import_from_nvd(hours_back=24, min_severity="HIGH"):
    """Importe les CVE depuis NVD de mani√®re dynamique"""
    print(f"\n{'='*60}")
    print("üîÑ IMPORTATION DYNAMIQUE NVD")
    print(f"{'='*60}")
    
    start_time = time.time()
    
    try:
        # Date : derni√®res X heures
        end_date = datetime.now(timezone.utc)
        start_date = end_date - timedelta(hours=hours_back)
        
        print(f"üìÖ P√©riode : {start_date.strftime('%Y-%m-%d %H:%M')} ‚Üí {end_date.strftime('%Y-%m-%d %H:%M')}")
        
        # Appel API NVD
        url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
        params = {
            "pubStartDate": start_date.strftime("%Y-%m-%dT%H:%M:%S"),
            "pubEndDate": end_date.strftime("%Y-%m-%dT%H:%M:%S"),
            "resultsPerPage": 200
        }
        
        response = requests.get(url, params=params, timeout=30)
        response.raise_for_status()
        data = response.json()
        
        total_cves = data.get('totalResults', 0)
        print(f"üì¶ {total_cves} CVE trouv√©es sur NVD")
        
        # Connexion base
        conn = sqlite3.connect("ctba.db")
        cursor = conn.cursor()
        
        added = 0
        severity_count = {"CRITICAL": 0, "HIGH": 0, "MEDIUM": 0, "LOW": 0}
        
        for vuln in data.get('vulnerabilities', []):
            cve_data = vuln.get('cve', {})
            cve_id = cve_data.get('id', '')
            
            # V√©rifier si existe d√©j√†
            cursor.execute("SELECT * FROM cves WHERE cve_id = ?", (cve_id,))
            if cursor.fetchone():
                continue  # D√©j√† dans la base
            
            # Extraire description
            description = "No description available"
            for desc in cve_data.get('descriptions', []):
                if desc.get('lang') == 'en':
                    description = desc.get('value', '')
                    break
            
            # Extraire s√©v√©rit√© et score
            severity = "LOW"
            score = 0.0
            metrics = cve_data.get('metrics', {})
            
            if 'cvssMetricV31' in metrics:
                severity = metrics['cvssMetricV31'][0]['cvssData']['baseSeverity']
                score = metrics['cvssMetricV31'][0]['cvssData']['baseScore']
            elif 'cvssMetricV30' in metrics:
                severity = metrics['cvssMetricV30'][0]['cvssData']['baseSeverity']
                score = metrics['cvssMetricV30'][0]['cvssData']['baseScore']
            elif 'cvssMetricV2' in metrics:
                score = metrics['cvssMetricV2'][0]['cvssData']['baseScore']
                if score >= 9.0: severity = "CRITICAL"
                elif score >= 7.0: severity = "HIGH"
                elif score >= 4.0: severity = "MEDIUM"
                else: severity = "LOW"
            
            # Compter par s√©v√©rit√©
            severity_count[severity] = severity_count.get(severity, 0) + 1
            
            # Filtrer par s√©v√©rit√© minimale
            severity_order = {"CRITICAL": 4, "HIGH": 3, "MEDIUM": 2, "LOW": 1}
            if severity_order.get(severity, 0) >= severity_order.get(min_severity, 2):
                try:
                    cursor.execute('''
                        INSERT INTO cves (cve_id, description, severity, cvss_score, published_date, imported_at)
                        VALUES (?, ?, ?, ?, ?, ?)
                    ''', (
                        cve_id,
                        description[:500],  # Limiter la longueur
                        severity,
                        float(score) if score else 0.0,
                        cve_data.get('published', ''),
                        datetime.now(timezone.utc).isoformat()
                    ))
                    added += 1
                    
                    # Afficher les critiques imm√©diatement
                    if severity == "CRITICAL":
                        print(f"  üö® {cve_id} - {severity} (Score: {score})")
                        
                except Exception as e:
                    print(f"  ‚ö†Ô∏è Erreur avec {cve_id}: {e}")
        
        # Enregistrer l'audit
        duration = time.time() - start_time
        cursor.execute('''
            INSERT INTO imports_audit (cves_found, cves_added, duration_seconds)
            VALUES (?, ?, ?)
        ''', (total_cves, added, duration))
        
        conn.commit()
        conn.close()
        
        # Afficher rapport
        print(f"\nüìä RAPPORT D'IMPORTATION :")
        print(f"  ‚úÖ Nouvelles CVE ajout√©es : {added}")
        print(f"  ‚è±Ô∏è  Dur√©e : {duration:.2f} secondes")
        print(f"  üéØ R√©partition par s√©v√©rit√© :")
        for sev, count in severity_count.items():
            if count > 0:
                print(f"    ‚Ä¢ {sev}: {count} CVE")
        
        # Notifier via WebSocket si nouvelles CVE
        if added > 0:
            asyncio.run(manager.broadcast(f"new_cves:{added}"))
            print(f"  üîî Notification envoy√©e aux clients")
        
        print(f"{'='*60}")
        return added
        
    except requests.exceptions.RequestException as e:
        print(f"‚ùå Erreur r√©seau NVD: {e}")
        return -1
    except Exception as e:
        print(f"‚ùå Erreur inattendue: {e}")
        return -1

# ========== 6. AUTOMATISATION ==========
def start_automation():
    """D√©marre l'automatisation des t√¢ches"""
    print("\nü§ñ D√âMARRAGE DE L'AUTOMATISATION")
    
    # Planifier les t√¢ches
    schedule.every(2).hours.do(lambda: import_from_nvd(hours_back=2, min_severity="HIGH"))
    schedule.every(1).days.at("08:00").do(lambda: import_from_nvd(hours_back=24, min_severity="MEDIUM"))
    
    # Ex√©cuter la premi√®re importation imm√©diatement
    print("‚ö° Premi√®re importation imm√©diate...")
    import_from_nvd(hours_back=6, min_severity="HIGH")
    
    # Lancer le scheduler dans un thread s√©par√©
    def scheduler_loop():
        print("‚è∞ Planificateur d√©marr√© (toutes les 2 heures)")
        while True:
            schedule.run_pending()
            time.sleep(60)  # V√©rifier toutes les minutes
    
    thread = threading.Thread(target=scheduler_loop, daemon=True)
    thread.start()
    
    return thread

# ========== 7. ROUTES API ==========
@app.get("/")
def root():
    """Page d'accueil"""
    conn = sqlite3.connect("ctba.db")
    cursor = conn.cursor()
    
    cursor.execute("SELECT COUNT(*) FROM cves")
    total_cves = cursor.fetchone()[0]
    
    cursor.execute("SELECT COUNT(*) FROM cves WHERE status = 'PENDING'")
    pending_cves = cursor.fetchone()[0]
    
    cursor.execute("SELECT MAX(import_date) FROM imports_audit")
    last_import = cursor.fetchone()[0]
    
    conn.close()
    
    return {
        "message": "CTBA API - Version Dynamique",
        "version": "2.0.0",
        "status": "running",
        "automation": "active",
        "statistics": {
            "total_cves": total_cves,
            "pending_cves": pending_cves,
            "last_import": last_import
        },
        "endpoints": [
            "GET /cves - Liste des CVE",
            "GET /cves/{cve_id} - D√©tail d'une CVE",
            "POST /cves/{cve_id}/decision - Valider/Rejeter",
            "GET /stats - Statistiques",
            "GET /import/now - Importer maintenant",
            "GET /automation/status - √âtat de l'automatisation",
            "WS /ws - WebSocket pour mises √† jour"
        ]
    }

@app.get("/cves")
def get_cves(
    status: Optional[str] = None,
    severity: Optional[str] = None,
    limit: int = 100
):
    """R√©cup√®re la liste des CVE"""
    conn = sqlite3.connect("ctba.db")
    conn.row_factory = sqlite3.Row
    cursor = conn.cursor()
    
    query = "SELECT * FROM cves WHERE 1=1"
    params = []
    
    if status:
        query += " AND status = ?"
        params.append(status)
    
    if severity:
        query += " AND severity = ?"
        params.append(severity)
    
    query += " ORDER BY published_date DESC LIMIT ?"
    params.append(limit)
    
    cursor.execute(query, params)
    cves = cursor.fetchall()
    conn.close()
    
    return [dict(cve) for cve in cves]

@app.get("/cves/{cve_id}")
def get_cve(cve_id: str):
    """R√©cup√®re les d√©tails d'une CVE"""
    conn = sqlite3.connect("ctba.db")
    conn.row_factory = sqlite3.Row
    cursor = conn.cursor()
    
    cursor.execute("SELECT * FROM cves WHERE cve_id = ?", (cve_id,))
    cve = cursor.fetchone()
    
    if not cve:
        raise HTTPException(status_code=404, detail="CVE non trouv√©e")
    
    cursor.execute(
        "SELECT * FROM decisions WHERE cve_id = ? ORDER BY decision_date DESC",
        (cve_id,)
    )
    decisions = cursor.fetchall()
    
    conn.close()
    
    return {
        "cve": dict(cve),
        "decisions": [dict(dec) for dec in decisions]
    }

@app.post("/cves/{cve_id}/decision")
def make_decision(cve_id: str, decision: dict):
    """Valide ou rejette une CVE"""
    if decision.get("decision") not in ["VALIDATED", "REJECTED"]:
        raise HTTPException(status_code=400, detail="D√©cision doit √™tre VALIDATED ou REJECTED")
    
    conn = sqlite3.connect("ctba.db")
    cursor = conn.cursor()
    
    # V√©rifier que la CVE existe
    cursor.execute("SELECT * FROM cves WHERE cve_id = ?", (cve_id,))
    if not cursor.fetchone():
        conn.close()
        raise HTTPException(status_code=404, detail="CVE non trouv√©e")
    
    # Enregistrer la d√©cision
    cursor.execute('''
        INSERT INTO decisions (cve_id, decision, analyst, comments)
        VALUES (?, ?, ?, ?)
    ''', (
        cve_id,
        decision.get("decision"),
        decision.get("analyst", "unknown"),
        decision.get("comments", "")
    ))
    
    # Mettre √† jour le statut de la CVE
    cursor.execute('''
        UPDATE cves SET status = ? WHERE cve_id = ?
    ''', (decision.get("decision"), cve_id))
    
    conn.commit()
    conn.close()
    
    # Notifier via WebSocket
    asyncio.run(manager.broadcast(f"decision:{cve_id}:{decision.get('decision')}"))
    
    return {
        "message": f"CVE {cve_id} {decision.get('decision')} avec succ√®s",
        "cve_id": cve_id,
        "decision": decision.get("decision"),
        "timestamp": datetime.now(timezone.utc).isoformat()
    }

@app.get("/stats")
def get_stats():
    """Statistiques d√©taill√©es des CVE"""
    conn = sqlite3.connect("ctba.db")
    conn.row_factory = sqlite3.Row
    cursor = conn.cursor()
    
    # Totaux
    cursor.execute("SELECT COUNT(*) as total FROM cves")
    total = cursor.fetchone()["total"]
    
    cursor.execute("SELECT COUNT(*) as pending FROM cves WHERE status = 'PENDING'")
    pending = cursor.fetchone()["pending"]
    
    # Par statut
    cursor.execute("SELECT status, COUNT(*) as count FROM cves GROUP BY status")
    by_status = {row["status"]: row["count"] for row in cursor.fetchall()}
    
    # Par s√©v√©rit√©
    cursor.execute("SELECT severity, COUNT(*) as count FROM cves GROUP BY severity")
    by_severity = {row["severity"]: row["count"] for row in cursor.fetchall()}
    
    # Derni√®res importations
    cursor.execute("""
        SELECT import_date, cves_found, cves_added, duration_seconds 
        FROM imports_audit 
        ORDER BY import_date DESC 
        LIMIT 5
    """)
    recent_imports = [dict(row) for row in cursor.fetchall()]
    
    # Activit√© r√©cente
    cursor.execute("""
        SELECT decision_date, decision, COUNT(*) as count 
        FROM decisions 
        WHERE decision_date >= datetime('now', '-7 days')
        GROUP BY DATE(decision_date), decision
        ORDER BY decision_date DESC
    """)
    recent_activity = [dict(row) for row in cursor.fetchall()]
    
    conn.close()
    
    return {
        "summary": {
            "total_cves": total,
            "pending_cves": pending,
            "processed_cves": total - pending
        },
        "distribution": {
            "by_status": by_status,
            "by_severity": by_severity
        },
        "automation": {
            "recent_imports": recent_imports,
            "import_count": len(recent_imports)
        },
        "activity": {
            "recent_decisions": recent_activity
        },
        "last_update": datetime.now(timezone.utc).isoformat()
    }

@app.get("/import/now")
def import_now():
    """D√©clenche une importation manuelle"""
    added = import_from_nvd(hours_back=6, min_severity="HIGH")
    return {
        "action": "manual_import",
        "cves_added": added,
        "timestamp": datetime.now(timezone.utc).isoformat()
    }

@app.get("/automation/status")
def automation_status():
    """Retourne l'√©tat de l'automatisation"""
    jobs = []
    for job in schedule.get_jobs():
        jobs.append({
            "next_run": str(job.next_run),
            "interval": str(job.interval),
            "unit": str(job.unit)
        })
    
    return {
        "automation": "active",
        "jobs_count": len(jobs),
        "jobs": jobs,
        "timestamp": datetime.now(timezone.utc).isoformat()
    }

# ========== 8. D√âMARRAGE ==========
if __name__ == "__main__":
    import uvicorn
    
    # Initialiser la base
    init_database()
    
    # D√©marrer l'automatisation
    automation_thread = start_automation()
    
    print("\n" + "="*60)
    print("üöÄ CTBA API - VERSION DYNAMIQUE")
    print("="*60)
    print("üìç Acc√®s API    : http://localhost:8000")
    print("üìö Documentation : http://localhost:8000/docs")
    print("üîå WebSocket    : ws://localhost:8000/ws")
    print("ü§ñ Automatisation : Active (toutes les 2 heures)")
    print("="*60)
    print("‚ö° Endpoints sp√©ciaux :")
    print("  ‚Ä¢ GET /import/now       ‚Üí Importation manuelle")
    print("  ‚Ä¢ GET /automation/status ‚Üí √âtat de l'automatisation")
    print("  ‚Ä¢ WS /ws                ‚Üí Mises √† jour temps r√©el")
    print("="*60)
    print("‚ö†Ô∏è  APPUYEZ SUR Ctrl+C POUR ARR√äTER")
    print("="*60)
    
    # D√©marrer le serveur
    uvicorn.run(
        "main:app",
        host="0.0.0.0",
        port=8000,
        reload=True
    )